{"mappings":"AAYA,oBAAoB,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,CAAC;AAC5E,yBAAyB,OAAO,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,CAAC;AAW7D,iCAAiC,CAAC,IAAI,EAAE;IACtC,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC9B,MAAM,CAAC,EAAE,UAAU,CAAC;CACrB,KAAK,IAAI,CAAC;AAEX,OAAO,MAAM,eAAe,kBAA6B,CAAC;AAI1D,kCAAkC,MAAM,EAAE,kBAAkB,QAE3D;AAED,OAAO,MAAM,wBAAyB,KAAK,SAE1C,CAAC;AAEF,OAAO,MAAM,sBAAuB,OAAO,MAAM,EAAE,GAAG,CAAC,SAEtD,CAAC;AAEF,OAAO,MAAM,kBAAmB,MAAM,EAAE,SAEvC,CAAC;AAEF,OAAO,MAAM,qBAAsB,MAAM,KAAK,MAAM,SAEnD,CAAC;AAEF,2BAA2B,CACzB,kBAAkB,CAAC,EAAE,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,EACjD,GAAG,CAAC,EAAE,MAAM,EACZ,GAAG,mBAAmB,EAAE,GAAG,EAAE,KAC1B,IAAI,CAAC;AAEV;IACE,KAAK,EAAE,YAAY,CAAC;IACpB,KAAK,EAAE,YAAY,CAAC;IACpB,IAAI,EAAE,YAAY,CAAC;IACnB,IAAI,EAAE,YAAY,CAAC;IACnB,KAAK,EAAE,YAAY,CAAC;IACpB,KAAK,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,KAAK,QAAQ,CAAC;CAClD;AAED,OAAO,MAAM,mBAAoB,MAAM,KAAG,QAsDtC,CAAC","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import pino from 'pino';\nimport { format } from 'date-fns';\nimport ja from 'date-fns/locale/ja';\nimport * as stackTraceParser from 'stacktrace-parser';\n\nconst options = {\n  logLevel: process.env.LOG_LEVEL ?? 'debug',\n  sharedContext: {},\n  masks: [] as string[],\n  maskFunc: (s: string) => `${s.substr(0, 8)}***`,\n};\n\nexport type Level = 'debug' | 'fatal' | 'error' | 'warn' | 'info' | 'trace';\nexport type StatusType = 'error' | 'warn' | 'info' | 'debug';\n\nconst PINO_TO_CONSOLE: Record<Level, StatusType> = {\n  debug: 'debug',\n  fatal: 'error',\n  error: 'error',\n  warn: 'warn',\n  info: 'info',\n  trace: 'info',\n};\n\nexport type ExternalLoggerType = (opts: {\n  message: string;\n  context?: Record<string, any>;\n  status?: StatusType;\n}) => void;\n\nexport const NO_OPS_LOGGER: ExternalLoggerType = () => {};\n\nlet _PRESENT_EXTERNAL_LOGGER = NO_OPS_LOGGER;\n\nexport function setExternalLogger(logger: ExternalLoggerType) {\n  _PRESENT_EXTERNAL_LOGGER = logger;\n}\n\nexport const setLogLevel = (logLevel: Level) => {\n  Object.assign(options, { logLevel });\n};\n\nexport const setContext = (context: Record<string, any>) => {\n  options.sharedContext = context;\n};\n\nexport const setMasks = (masks: string[]) => {\n  options.masks = masks;\n};\n\nexport const setMaskFunc = (f: (s: string) => string) => {\n  options.maskFunc = f;\n};\n\nexport type AGLoggerFunc = (\n  msgOrMergingObject?: string | Record<string, any>,\n  msg?: string,\n  ...interpolationValues: any[]\n) => void;\n\nexport interface AGLogger {\n  fatal: AGLoggerFunc;\n  error: AGLoggerFunc;\n  warn: AGLoggerFunc;\n  info: AGLoggerFunc;\n  debug: AGLoggerFunc;\n  child: (params: Record<string, any>) => AGLogger;\n}\n\nexport const logFactory = (name: string): AGLogger =>\n  pino({\n    name,\n    level: options.logLevel,\n    formatters: {\n      bindings: () => ({}), // omit pid and hostname\n      log: (o) =>\n        Object.fromEntries(\n          Object.entries(o).map(([k, v]) => [\n            k,\n            options.masks.findIndex((ele) => ele === k) >= 0 && (typeof v === 'string' || typeof v === 'number')\n              ? options.maskFunc(`${v}`)\n              : k === 'stack' && typeof v === 'string'\n              ? stackTraceParser.parse(v)\n              : v,\n          ])\n        ),\n    },\n    browser: {\n      serialize: true,\n      write: (o) => {\n        const { type, stack, level, time, msg, ...rest } = o as {\n          type?: 'Error'; // exist when logger.error is used\n          stack?: string; // exist when logger.error is used\n          level: number; // this is not a label (maybe this is a spec. bug)\n          time: number;\n          msg?: string;\n        };\n\n        const timeLabel = format(new Date(time), 'HH:mm:ss', { locale: ja });\n        const levelLabel = PINO_TO_CONSOLE[pino.levels.labels[`${level}`] as Level];\n\n        const s = `${timeLabel} [${name}] ${msg ?? ''}`;\n\n        const masked = Object.fromEntries(\n          Object.entries(rest).map(([k, v]) => [\n            k,\n            options.masks.findIndex((ele) => ele === k) >= 0 && (typeof v === 'string' || typeof v === 'number')\n              ? options.maskFunc(`${v}`)\n              : k === 'stack' && typeof v === 'string'\n              ? stackTraceParser.parse(v)\n              : v,\n          ])\n        );\n\n        if (Object.keys(masked).length) {\n          console[levelLabel](s, masked);\n        } else {\n          console[levelLabel](s);\n        }\n\n        _PRESENT_EXTERNAL_LOGGER({ message: msg ?? '', context: { logger: name, ...masked }, status: levelLabel });\n      },\n    },\n  });\n"],"names":[],"version":3,"file":"index.d.ts.map"}