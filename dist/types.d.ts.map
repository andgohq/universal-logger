{"mappings":";;AAIA,oBAAoB,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,CAAC;AAC5E,yBAAyB,OAAO,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,CAAC;AAC7D,oBAAoB,KAAK,KAAK,CAAC;AAC/B,iCAAiC,CAAC,IAAI,EAAE;IACtC,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC9B,MAAM,CAAC,EAAE,UAAU,CAAC;CACrB,KAAK,IAAI,CAAC;AAEX;IACE,KAAK,EAAE,KAAK,CAAC;IACb,KAAK,EAAE,KAAK,CAAC;IACb,IAAI,EAAE,KAAK,CAAC;IACZ,IAAI,EAAE,KAAK,CAAC;IACZ,KAAK,EAAE,KAAK,CAAC;IACb,KAAK,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,KAAK,QAAQ,CAAC;CAClD;AAED,OAAO,MAAM,eAAe,kBAA6B,CAAC;AAgC1D,QAAA,MAAM;;;;kBAIU,MAAM;;;;CAIrB,CAAC;AAEF,OAAO,MAAM,yBAA0B,QAAQ,cAAc,CAAC,SAE7D,CAAC;AAEF,kCAAkC,MAAM,EAAE,kBAAkB,QAE3D;AAED,OAAO,MAAM,uBAAwB,iBAAiB,SAErD,CAAC;AA+CF,OAAO,MAAM,mBAAoB,MAAM,KAAG,QAoDtC,CAAC","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import pino from 'pino';\nimport StackTracey from 'stacktracey';\nimport chalkModule from 'chalk';\n\nexport type Level = 'debug' | 'fatal' | 'error' | 'warn' | 'info' | 'trace';\nexport type StatusType = 'error' | 'warn' | 'info' | 'debug';\nexport type LogFn = pino.LogFn;\nexport type ExternalLoggerType = (opts: {\n  message: string;\n  context?: Record<string, any>;\n  status?: StatusType;\n}) => void;\n\nexport interface AGLogger {\n  fatal: LogFn;\n  error: LogFn;\n  warn: LogFn;\n  info: LogFn;\n  debug: LogFn;\n  child: (params: Record<string, any>) => AGLogger;\n}\n\nexport const NO_OPS_LOGGER: ExternalLoggerType = () => {};\n\nconst DEFAULT_MASK_LENGTH = 8;\nconst DEFAULT_CHALK_LEVEL = 1;\n\nconst dateTimeFormatter = new Intl.DateTimeFormat('ja-jp', {\n  hour: '2-digit',\n  minute: '2-digit',\n  second: '2-digit',\n});\n\nconst LEVEL_TO_CONSOLE: Record<Level, StatusType> = {\n  debug: 'debug',\n  fatal: 'info',\n  error: 'info',\n  warn: 'warn',\n  info: 'info',\n  trace: 'info',\n};\n\nconst LEVEL_TO_LABEL: Record<Level, string> = {\n  debug: 'D',\n  fatal: 'F',\n  error: 'E',\n  warn: 'W',\n  info: 'I',\n  trace: 'I',\n};\n\nlet chalk = new chalkModule.Instance({ level: DEFAULT_CHALK_LEVEL });\nlet PRESENT_EXTERNAL_LOGGER = NO_OPS_LOGGER;\n\nconst OPTIONS = {\n  level: (process.env.LOG_LEVEL ?? 'debug') as Level,\n  context: {} as Record<string, any>,\n  maskTargets: [] as string[],\n  maskFunc: (s: string) => `${s.substring(0, DEFAULT_MASK_LENGTH)}***`,\n  browser: {\n    inline: false,\n  },\n};\n\nexport const updateOptions = (options: Partial<typeof OPTIONS>) => {\n  Object.assign(OPTIONS, options);\n};\n\nexport function setExternalLogger(logger: ExternalLoggerType) {\n  PRESENT_EXTERNAL_LOGGER = logger;\n}\n\nexport const setColorLevel = (level: chalkModule.Level) => {\n  chalk = new chalkModule.Instance({ level });\n};\n\nconst serializer = (k: string, v: any) => {\n  const isMaskTarget =\n    OPTIONS.maskTargets.findIndex((ele) => ele === k) >= 0 && (typeof v === 'string' || typeof v === 'number');\n\n  if (isMaskTarget) {\n    return OPTIONS.maskFunc(`${v}`);\n  } else {\n    return v;\n  }\n};\n\nconst transform = (obj: Record<string, any>) => {\n  return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, serializer(k, v)]));\n};\n\nconst pickExists = (obj: Record<string, any>) => {\n  return Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined));\n};\n\nconst summarize = (obj: Record<string, any>) => {\n  // omit stack, level, time, msg from the parameter object\n  const { type, message, stack, err, msg, ...rest } = obj as {\n    // properties when the object is Error instance\n    // error style 1\n    type?: 'Error';\n    message?: string; // exist when logger.error is used\n    stack?: string; // exist when logger.error is used\n    // error style 2\n    err?: Error;\n    // standard properties\n    msg?: string;\n  };\n\n  const isErrorMode = (type == 'Error' && stack) || err;\n  const finalMsg = (isErrorMode ? msg ?? message ?? err?.message : msg) ?? '';\n  const finalParams = {\n    ...transform(rest),\n    ...(isErrorMode\n      ? { stack: new StackTracey(stack ?? err?.stack ?? '').items.map((item) => item.beforeParse) }\n      : pickExists({ type, message, stack })),\n  };\n\n  return { msg: finalMsg, ...finalParams };\n};\n\nexport const logFactory = (name: string): AGLogger =>\n  pino({\n    name,\n    level: OPTIONS.level,\n    formatters: {\n      // omit pid and hostname\n      bindings: ({ name }) => ({ name }),\n      // for nodejs environment only\n      log: (o) => {\n        const { level, time, ...rest } = o as Record<string, any>;\n\n        return { level, time, ...summarize(rest) };\n      },\n    },\n    browser: {\n      // use Pino's standard serializers\n      // https://github.com/pinojs/pino-std-serializers\n      serialize: false,\n      write: (o) => {\n        const { level, time, ...rest } = o as Record<string, any>;\n        const { msg, ...params } = summarize(rest);\n\n        const LEVEL_TO_COLOR: Record<Level, typeof chalkModule.Instance | ((s: string) => string)> = {\n          debug: chalk.gray,\n          fatal: chalk.bgRed.white,\n          error: chalk.red,\n          warn: chalk.yellow,\n          info: (s: string) => s,\n          trace: (s: string) => s,\n        };\n\n        const color = LEVEL_TO_COLOR[pino.levels.labels[`${level}`]];\n        const timeLabel = dateTimeFormatter.format(time);\n        const levelKey = pino.levels.labels[`${level}`] as Level;\n        const consoleKey = LEVEL_TO_CONSOLE[levelKey];\n        const levelLabel = LEVEL_TO_LABEL[levelKey];\n\n        const s = `${timeLabel} ${levelLabel} [${name}] ${msg}`;\n\n        if (Object.keys(params).length) {\n          if (OPTIONS.browser.inline) {\n            console[consoleKey](color(`${s} ${JSON.stringify(params)}`));\n          } else {\n            console[consoleKey](color(s), params);\n          }\n        } else {\n          console[consoleKey](color(s));\n        }\n\n        PRESENT_EXTERNAL_LOGGER({ message: msg || '', context: { logger: name, ...params }, status: consoleKey });\n      },\n    },\n  });\n"],"names":[],"version":3,"file":"types.d.ts.map"}